<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>functions on The Python Corner</title><link>https://mastro35.github.io/tpc/tags/functions/</link><description>Recent content in functions on The Python Corner</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Davide Mastromatteo</copyright><lastBuildDate>Wed, 30 Dec 2020 12:55:36 +0100</lastBuildDate><atom:link href="https://mastro35.github.io/tpc/tags/functions/index.xml" rel="self" type="application/rss+xml"/><item><title>Working with decorators in Python - The Basics</title><link>https://mastro35.github.io/tpc/posts/2020-12-30-working-with-decorators-python-basics/</link><pubDate>Wed, 30 Dec 2020 12:55:36 +0100</pubDate><guid>https://mastro35.github.io/tpc/posts/2020-12-30-working-with-decorators-python-basics/</guid><description>Hi Guys, in todayâ€™s article, we will discuss Python decorators.
Decorators are not a python-only feature, they exist in many other languages and are important if you aim to write clean, professional, and reusable code.
A decorator is a function that extends other functions that are passed as a parameter, adding new features without the need of changing their code.
This can seem a little magical to a beginner&amp;rsquo;s eye, but it&amp;rsquo;s really easy actually because all you have to do is to create a function (the so-called &amp;ldquo;decorator function&amp;quot;) that takes another function as an argument (the &amp;ldquo;decorated function&amp;quot;) and returns a completely new function that simply modify the behavior of your decorated function.</description></item></channel></rss>